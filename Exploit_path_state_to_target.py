# This script enumerate the criticality of paths generated from specific source (logical) to specific target (logical) in the attack surface
# The attack surface is represented through a graph which is initiated aligning with input data properties e.graph., ('VERTICES.CSV') and ('ARCS.CSV')
# The graph represents the logical state of attacker which is defined as attack graph state (AG_state)
# It creates the path from specific source state to target state. Both are set by the user
# Prior analyzing the vulnerability and correlation between states within paths it measures the criticality of paths



# first we import all necessary module exploit
import json
from graph_tool.all import *
import time
import numpy as np
import re
import random
from collections import deque
import csv


graph = Graph() # creating a graph

# intialize the vertex property 

graph.vp["nid"] = graph.new_vp("string") # assign the id of each node which is a numeric number
graph.vp["label"] = graph.new_vp("string") # initialize if the node is configuration, rule or impact
graph.vp["shape"] = graph.new_vp("string") # shape of the node: if the node is 'AND' node or 'OR' node


# now load the graph with the data sample we have 
from loading_graph_func import load_graph

# put the appropriate input file
vertice_file=input('put vertices file \n')
arc_file=input('put arcs file \n')
load_graph(graph, vertice_file, arc_file)


# now decompose the attack graph into state graph 
# The state graph also includes the Ip address related to each state corresponding to the physical machine
# each state represents all information corresponding to distinct attacker's action
AG_states = {} # states of the attack graphs
for v in graph.vertices():
    if graph.vp["shape"][v] == "AND":
        impacts = map(lambda x:x.source(), v.in_edges()) # find impact nodes
        out_states = []
        for impact in impacts:
            label=graph.vp["label"][impact]
            IP_add=re.findall(r"(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})", label)[0] # find IP address
            for edge in impact.in_edges():
                out_states.append(int(edge.source()))
        conds = map(lambda x:x.target(), v.out_edges()) # find conditions which are the configurations allowing attack to be happen
        in_states = []
        conditions = []
        for cond in conds:
            if graph.vp["shape"][cond] == "OR":
                for edge in cond.out_edges():
                    in_states.append(int(edge.target()))
            elif graph.vp["shape"][cond] == "LEAF":
                conditions.append(int(cond))
                label=graph.vp["label"][cond]
                # Now find IP address of nodes which have configurations
                IP_add_temp=re.findall(r"(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})", label)
                if 'nfsExportInfo' in label:
                    IP_add=re.findall(r"(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})", label)[1]
                elif len(IP_add_temp)!=0:
                    IP_add=re.findall(r"(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})", label)[0]

        AG_states[int(v)] = {# "in"  : map(lambda x:int(x.target()), v.out_edges()),
                          # "out" : map(lambda x:int(x.source()), v.in_edges())
                          # "conditions" : conditions + in_states,
                          "IP_address" : IP_add,
                          "conditions" : conditions,
                          "out_states" : out_states, # next state connected to the current state
                          "in_states" : in_states} # earlier state connecting to the current state


print(AG_states.keys()) # shows all attack states



# now importing vulnerability database
with open('vul_comp_risk.json', 'r') as f:
    vulnerability_risk = json.load(f) # database having the risk of vulnerability enumerated


# now importing technique score database
with open('tech_score.json', 'r') as f:
    technique_score = json.load(f) # score of technique from MITRE ATT&CK
    
# now importing technique rule mapping database
with open('rule_tech_data.json', 'r') as f:
    tech_map_data = json.load(f) # mapping of technique with attack graph




# Now analyze the internal properties of each state
# first work with vulnerable component risk 
for key in AG_states.keys():
    alpha_score = 1
    for cond in AG_states[key]["conditions"]:
        if "vulExists" == graph.vp["label"][cond][:9]:
            cond_string=graph.vp['label'][cond]
            vulnerability=re.findall(r"CVE[^']*",cond_string) # find CVE id from attack graph data
            alpha_score = vulnerability_risk[vulnerability[0]]['vul_component_risk'] # vulnerability risk of CVE found from attack graph
  
    AG_states[key]["alpha_score"]=alpha_score

    rule_parm=graph.vp["label"][key]
    rule=re.findall(r"\((.*?)\)",rule_parm)
    tech_applied=tech_map_data[rule[0]]['technique'] # find which technique is mapped with particular attack graph state
    AG_states[key]["tech_score"]=technique_score[tech_applied]['tech_score'] # score of technique mapped with attack graph

    

# it takes every node as a target node 
impact_node_id = [] # node id of impact node
for v in graph.vertices():
    if graph.vp["shape"][v] == "OR":
        impact_node_id.append(graph.vp["nid"][v])
        
        


# initialize target node, source state and source IP
# Defender can change the number based on his environemnt 
# Attack graph starts from target state or target IP and end to the target node

impact_node_id = input("Insert target state- \n") # target node, the node defender needs to protect; Attack graph end to this node
source_state=int(input("Insert state address of assumed attacker loaction- \n")) # More granular information. State of a source node, attack graph starts from this specific state 



# now import the function to create attack paths
from finding_path_state_to_target import search_attack_paths_state_to_target


#Finding attack paths from a particular state to target

attack_paths = {} # initalize dictionary for all attack paths
for impact_nid in impact_node_id:
    attack_paths[impact_nid] = {}
    start = find_vertex(graph, graph.vp["nid"], impact_nid)
    paths = search_attack_paths_state_to_target(graph, int(start[0]), source_state, 100) # we path finding limitation to 100 paths, you can change it
    path_count = len(paths)
    sample = random.sample(range(path_count), min(path_count, path_count))
    
    
    for index in sample:
        attack_paths[impact_nid][index] = {}
        path = paths[index][0]
        
        a = np.array(path) 
        a = a.ravel()
        
        path_states = filter(lambda x:graph.vp["shape"][x] == "AND", a) # attack graph states included in the path
        deduplicated_path_states = []
        for p_state in path_states:
            if p_state not in deduplicated_path_states:
                deduplicated_path_states.append(p_state)
        
        path_states = list(reversed(deduplicated_path_states))
        
        attack_paths[impact_nid][index]["path"] = path_states # attack paths comprising the states an attacker propagated
        


# here we extract the parameters from 'cond' node which is configuration node in the attack graph
# these parameters will be used to measure the correlation between different states
def params(v):
    if graph.vp["shape"][v] != "AND":
        label = (graph.vp["label"][v]).replace("(",",").replace(")","")
        return label.split(",")[1:]

    

# extract unique parameters
def state_cond_params(states, state):
    parameters = []
    for v in  states[state]["conditions"]:
        parameters = parameters + params(v)
    return np.unique(parameters)



# Now we measure the correlation score between different states
def correlation_score(states, state1, state2):
    param1 = state_cond_params(states, state1)
    param2 = state_cond_params(states, state2)
    intersection = np.intersect1d(param1, param2)
    union = np.union1d(param1, param2)
    if len(union) == 0:
        return 1.0
    return float(len(intersection))/len(union)



# Now measure the path exploit of all paths

import math
decay_factor = 2 # the decay factor defines how much effort reduced given attacker face the exact same environment in a state like he faced before

for impact in attack_paths.keys():
#     print ("Impact ", impact, " : ", attack_paths[impact])
    for path_index in attack_paths[impact].keys():
        attack_paths[impact][path_index]["state_path_exploit"]=list(np.zeros(len(attack_paths[impact][path_index]["path"])))
        
        for index in range(len(attack_paths[impact][path_index]["path"])):
            exploit = 0.0
            accum_corr=0.0
            state1 = attack_paths[impact][path_index]["path"][index]
            for j in range(index):
                state2 = attack_paths[impact][path_index]["path"][j]
                accum_corr = accum_corr + correlation_score(AG_states, state1, state2) # sum of correlation score
            state_path_exploit = (1.0 /AG_states[state1]["alpha_score"]) + (1.0/AG_states[state1]["tech_score"]) # exploit of each state in the attack graph
            state_path_exploit = math.exp(-accum_corr/decay_factor) * state_path_exploit
            attack_paths[impact][path_index]["state_path_exploit"][index] = state_path_exploit
        attack_paths[impact][path_index]["path_exploit"] = sum(attack_paths[impact][path_index]["state_path_exploit"]) # exploit of each attack path   
        
        
#The path_exploit shows the exploitability of the whole path. While the state_path_exploit shows the exploit of each state in a path. The state represents the attacker's action with corresponding factors such as conditions etc. The state_exploit shows the correlated exploit of the each state estimated by our algorithm and results the path exploit. The higher exploit means higher effort attacker needs to traverse the path. 



print(attack_paths)














